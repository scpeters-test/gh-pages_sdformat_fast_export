{"links": {"self": {"href": "data/repositories/osrf/sdformat/pullrequests/524/comments/99731378.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/sdformat/diff/osrf/sdformat:5d19002bafc2..0704cc62db40?path=src%2FAtmosphere.cc"}, "html": {"href": "#!/osrf/sdformat/pull-requests/524/_/diff#comment-99731378"}}, "parent": {"id": 99728309, "links": {"self": {"href": "data/repositories/osrf/sdformat/pullrequests/524/comments/99728309.json"}, "html": {"href": "#!/osrf/sdformat/pull-requests/524/_/diff#comment-99728309"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 524, "links": {"self": {"href": "data/repositories/osrf/sdformat/pullrequests/524.json"}, "html": {"href": "#!/osrf/sdformat/pull-requests/524"}}, "title": "Rule of five for various DOM classes"}, "content": {"raw": "> Good point. I think people will argue that an object shouldn't be used after it has been moved.\n\nI agree. Calling any other member function would be invalid. But I think copy assigning should still be valid. This is what happens in `std::swap` if the class doesn't have a move assignment operator but does have a move constructor. \n\n> Also, you want to follow this approach then you should probably create new dataPtr for the moved object in the move operator and constructor. Otherwise you'll need this if statement in each accessor/setter.\n\nThis is true. I'm inclined to say moved from objects don't have a valid state and calling any member function except assignment is undefined. In my mind, this seems to be the simplest approach. There is some discussion [here](https://stackoverflow.com/questions/12095048/what-constitutes-a-valid-state-for-a-moved-from-object-in-c11) about how moved from objects are supposed to behave. What you suggest is (allocating a new `dataPtr`) is valid, but it would incur the cost of heap allocation, which is expensive while moving should theoretically be cheap. \n", "markup": "markdown", "html": "<blockquote>\n<p>Good point. I think people will argue that an object shouldn't be used after it has been moved.</p>\n</blockquote>\n<p>I agree. Calling any other member function would be invalid. But I think copy assigning should still be valid. This is what happens in <code>std::swap</code> if the class doesn't have a move assignment operator but does have a move constructor. </p>\n<blockquote>\n<p>Also, you want to follow this approach then you should probably create new dataPtr for the moved object in the move operator and constructor. Otherwise you'll need this if statement in each accessor/setter.</p>\n</blockquote>\n<p>This is true. I'm inclined to say moved from objects don't have a valid state and calling any member function except assignment is undefined. In my mind, this seems to be the simplest approach. There is some discussion <a data-is-external-link=\"true\" href=\"https://stackoverflow.com/questions/12095048/what-constitutes-a-valid-state-for-a-moved-from-object-in-c11\" rel=\"nofollow\">here</a> about how moved from objects are supposed to behave. What you suggest is (allocating a new <code>dataPtr</code>) is valid, but it would incur the cost of heap allocation, which is expensive while moving should theoretically be cheap. </p>", "type": "rendered"}, "created_on": "2019-04-23T21:19:53.060390+00:00", "user": {"display_name": "Addisu Z. Taddese", "uuid": "{9d7fdc68-d270-4080-bf03-4df0d0dbf635}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D"}, "html": {"href": "https://bitbucket.org/%7B9d7fdc68-d270-4080-bf03-4df0d0dbf635%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:90bc87b0-2886-4377-a17c-3a6629a697ff/afbf9be5-1e4c-4810-89d4-e58831f34b11/128"}}, "nickname": "azeey", "type": "user", "account_id": "557058:90bc87b0-2886-4377-a17c-3a6629a697ff"}, "inline": {"to": 67, "from": null, "outdated": true, "path": "src/Atmosphere.cc"}, "updated_on": "2019-04-23T21:19:53.072869+00:00", "type": "pullrequest_comment", "id": 99731378}