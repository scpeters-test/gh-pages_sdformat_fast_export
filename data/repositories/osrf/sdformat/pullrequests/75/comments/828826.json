{"links": {"self": {"href": "data/repositories/osrf/sdformat/pullrequests/75/comments/828826.json"}, "html": {"href": "#!/osrf/sdformat/pull-requests/75/_/diff#comment-828826"}}, "parent": {"id": 827491, "links": {"self": {"href": "data/repositories/osrf/sdformat/pullrequests/75/comments/827491.json"}, "html": {"href": "#!/osrf/sdformat/pull-requests/75/_/diff#comment-827491"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 75, "links": {"self": {"href": "data/repositories/osrf/sdformat/pullrequests/75.json"}, "html": {"href": "#!/osrf/sdformat/pull-requests/75"}}, "title": "Do not export urdf symbols in sdformat 1.4 (-> sdf_1.4)"}, "content": {"raw": "Are you referring to the C++ namespace? They do not impact the symbol visibility unfortunately. A valid way to reduce symbol visibility is to use the \"static\" C-keyword on functions. However, there is no such mechanism for classes or methods. Also, static is stricter than a \"not exported\" symbol. \"static\" reduce visibility to the same object file whereas not exporting a symbol is limiting the ABI to the current DSO (Dynamic Shared Object). You can play with \"nm\" or \"objdump\" and you will see that namespaces will change your symbols *names* not your symbols *types*.\n\nAlso, fighting with symbols is also fighting against the leakage of unwanted symbols defined by the libraries you depend on (Boost, for instance). If properly wrapped and used internally only, you really have one library A using Boost 1.39 and another library B using Boost 1.40 without any issue even if the ABI is different on the two releases. As long as no Boost types are exposed in the API it will be ok. By making all symbols hidden by default, you will also tag as hidden all the Boost related symbols you will create by instating templates. Therefore, it is very easy to see a 50% drop in the number of symbols by just tagging symbols explicitly. See http://gcc.gnu.org/wiki/Visibility for more information.", "markup": "markdown", "html": "<p>Are you referring to the C++ namespace? They do not impact the symbol visibility unfortunately. A valid way to reduce symbol visibility is to use the \"static\" C-keyword on functions. However, there is no such mechanism for classes or methods. Also, static is stricter than a \"not exported\" symbol. \"static\" reduce visibility to the same object file whereas not exporting a symbol is limiting the ABI to the current DSO (Dynamic Shared Object). You can play with \"nm\" or \"objdump\" and you will see that namespaces will change your symbols <em>names</em> not your symbols <em>types</em>.</p>\n<p>Also, fighting with symbols is also fighting against the leakage of unwanted symbols defined by the libraries you depend on (Boost, for instance). If properly wrapped and used internally only, you really have one library A using Boost 1.39 and another library B using Boost 1.40 without any issue even if the ABI is different on the two releases. As long as no Boost types are exposed in the API it will be ok. By making all symbols hidden by default, you will also tag as hidden all the Boost related symbols you will create by instating templates. Therefore, it is very easy to see a 50% drop in the number of symbols by just tagging symbols explicitly. See <a href=\"http://gcc.gnu.org/wiki/Visibility\" rel=\"nofollow\" class=\"ap-connect-link\">http://gcc.gnu.org/wiki/Visibility</a> for more information.</p>", "type": "rendered"}, "created_on": "2013-11-18T06:18:09.806330+00:00", "user": {"display_name": "Thomas Moulard", "uuid": "{e1f47898-cedc-4c14-a637-d0c43400e843}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be1f47898-cedc-4c14-a637-d0c43400e843%7D"}, "html": {"href": "https://bitbucket.org/%7Be1f47898-cedc-4c14-a637-d0c43400e843%7D/"}, "avatar": {"href": "https://bitbucket.org/account/thomas_moulard/avatar/"}}, "nickname": "thomas_moulard", "type": "user", "account_id": null}, "updated_on": "2013-11-18T06:18:09.926345+00:00", "type": "pullrequest_comment", "id": 828826}