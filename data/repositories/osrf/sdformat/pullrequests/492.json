{"rendered": {"description": {"raw": "Fix for the issue described in [#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if](#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if) and other potential errors due to the use of `std::stringstream`.\r\n\r\n~~For uniforming the code, handling of double and float parameters have been switched to use~~ `std::stringstream` ~~as well.~~\r\n\r\nThere are two separated fixes:\r\n\r\n* Introduce a private helper `StringStreamClassicLocale` that is just `std::stringstream` with `imbue(std::locale::classic()` called in the constructor. Use of this helper ensures that the parsing is independent from the C\\+\\+ global locale set via `std::locale::global()`.\r\n* Move the `setlocale(LC_NUMERIC, \"C\");` from `Param::SetFromString` to `Param::ValueFromString`, so the case in which the `Param::ValueFromString` method was first called by the Param constructor is covered as well.\r\n\r\nIf necessary, it is possible to split this two fixes in two PRs.\r\n\r\nI would have preferred to switch all conversions to C\\+\\+ facilities, removing the existing modifications of the global C locale, that are error-prone as any thread in the process could call `std::locale(\"\")` between sdformat's `std::locale` call and the calls to `stod` and `stof`.\r\n\r\nUnfortunately it turns out that removing `std::stod` is not trivial, as `stod` supports reading hexadecimal floating point numbers \\([https://en.cppreference.com/w/cpp/string/basic\\_string/stof](https://en.cppreference.com/w/cpp/string/basic_string/stof)\\), that are not supported instead by `stringstream& operator>>(double& value);` . The situation on this is a bit confusing from a user point of view, because as far as I could find, sdformat specification does not specify which representations it supports for double and float numbers. XML-based formats typically stick to support only `xsd::double` \\(see [https://www.w3.org/TR/xmlschema-2/#double](https://www.w3.org/TR/xmlschema-2/#double) and [https://github.com/ros/urdfdom\\_headers/issues/41#issuecomment-345737929](https://github.com/ros/urdfdom_headers/issues/41#issuecomment-345737929)\\) that **does not** support hexadecimal doubles, and indeed this is what is documented in the XML Schema generated by sdformat. Furthermore, hexadecimal double are only supported in scalar values, while when reading vectors the only representations supported are the one supported by `stringstream& operator>>(double& value);` . It probably make sense to discuss this in a separate issue.", "markup": "markdown", "html": "<p>Fix for the issue described in <a data-is-external-link=\"true\" href=\"#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if\" rel=\"nofollow\">#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if</a> and other potential errors due to the use of <code>std::stringstream</code>.</p>\n<p><del>For uniforming the code, handling of double and float parameters have been switched to use</del> <code>std::stringstream</code> <del>as well.</del></p>\n<p>There are two separated fixes:</p>\n<ul>\n<li>Introduce a private helper <code>StringStreamClassicLocale</code> that is just <code>std::stringstream</code> with <code>imbue(std::locale::classic()</code> called in the constructor. Use of this helper ensures that the parsing is independent from the C++ global locale set via <code>std::locale::global()</code>.</li>\n<li>Move the <code>setlocale(LC_NUMERIC, \"C\");</code> from <code>Param::SetFromString</code> to <code>Param::ValueFromString</code>, so the case in which the <code>Param::ValueFromString</code> method was first called by the Param constructor is covered as well.</li>\n</ul>\n<p>If necessary, it is possible to split this two fixes in two PRs.</p>\n<p>I would have preferred to switch all conversions to C++ facilities, removing the existing modifications of the global C locale, that are error-prone as any thread in the process could call <code>std::locale(\"\")</code> between sdformat's <code>std::locale</code> call and the calls to <code>stod</code> and <code>stof</code>.</p>\n<p>Unfortunately it turns out that removing <code>std::stod</code> is not trivial, as <code>stod</code> supports reading hexadecimal floating point numbers (<a data-is-external-link=\"true\" href=\"https://en.cppreference.com/w/cpp/string/basic_string/stof\" rel=\"nofollow\">https://en.cppreference.com/w/cpp/string/basic_string/stof</a>), that are not supported instead by <code>stringstream&amp; operator&gt;&gt;(double&amp; value);</code> . The situation on this is a bit confusing from a user point of view, because as far as I could find, sdformat specification does not specify which representations it supports for double and float numbers. XML-based formats typically stick to support only <code>xsd::double</code> (see <a data-is-external-link=\"true\" href=\"https://www.w3.org/TR/xmlschema-2/#double\" rel=\"nofollow\">https://www.w3.org/TR/xmlschema-2/#double</a> and <a data-is-external-link=\"true\" href=\"https://github.com/ros/urdfdom_headers/issues/41#issuecomment-345737929\" rel=\"nofollow\">https://github.com/ros/urdfdom_headers/issues/41#issuecomment-345737929</a>) that <strong>does not</strong> support hexadecimal doubles, and indeed this is what is documented in the XML Schema generated by sdformat. Furthermore, hexadecimal double are only supported in scalar values, while when reading vectors the only representations supported are the one supported by <code>stringstream&amp; operator&gt;&gt;(double&amp; value);</code> . It probably make sense to discuss this in a separate issue.</p>", "type": "rendered"}, "title": {"raw": "Fix locale problems of std::stringstream and of Param::ValueFromString", "markup": "markdown", "html": "<p>Fix locale problems of std::stringstream and of Param::ValueFromString</p>", "type": "rendered"}}, "type": "pullrequest", "description": "Fix for the issue described in [#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if](#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if) and other potential errors due to the use of `std::stringstream`.\r\n\r\n~~For uniforming the code, handling of double and float parameters have been switched to use~~ `std::stringstream` ~~as well.~~\r\n\r\nThere are two separated fixes:\r\n\r\n* Introduce a private helper `StringStreamClassicLocale` that is just `std::stringstream` with `imbue(std::locale::classic()` called in the constructor. Use of this helper ensures that the parsing is independent from the C\\+\\+ global locale set via `std::locale::global()`.\r\n* Move the `setlocale(LC_NUMERIC, \"C\");` from `Param::SetFromString` to `Param::ValueFromString`, so the case in which the `Param::ValueFromString` method was first called by the Param constructor is covered as well.\r\n\r\nIf necessary, it is possible to split this two fixes in two PRs.\r\n\r\nI would have preferred to switch all conversions to C\\+\\+ facilities, removing the existing modifications of the global C locale, that are error-prone as any thread in the process could call `std::locale(\"\")` between sdformat's `std::locale` call and the calls to `stod` and `stof`.\r\n\r\nUnfortunately it turns out that removing `std::stod` is not trivial, as `stod` supports reading hexadecimal floating point numbers \\([https://en.cppreference.com/w/cpp/string/basic\\_string/stof](https://en.cppreference.com/w/cpp/string/basic_string/stof)\\), that are not supported instead by `stringstream& operator>>(double& value);` . The situation on this is a bit confusing from a user point of view, because as far as I could find, sdformat specification does not specify which representations it supports for double and float numbers. XML-based formats typically stick to support only `xsd::double` \\(see [https://www.w3.org/TR/xmlschema-2/#double](https://www.w3.org/TR/xmlschema-2/#double) and [https://github.com/ros/urdfdom\\_headers/issues/41#issuecomment-345737929](https://github.com/ros/urdfdom_headers/issues/41#issuecomment-345737929)\\) that **does not** support hexadecimal doubles, and indeed this is what is documented in the XML Schema generated by sdformat. Furthermore, hexadecimal double are only supported in scalar values, while when reading vectors the only representations supported are the one supported by `stringstream& operator>>(double& value);` . It probably make sense to discuss this in a separate issue.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/sdformat/pullrequests/492/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/sdformat/diffstat/osrf/sdformat:075d85ff6c88%0Dd2436327aef2?from_pullrequest_id=492"}, "commits": {"href": "data/repositories/osrf/sdformat/pullrequests/492/commits.json"}, "self": {"href": "data/repositories/osrf/sdformat/pullrequests/492.json"}, "comments": {"href": "data/repositories/osrf/sdformat/pullrequests/492/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/sdformat/pullrequests/492/merge"}, "html": {"href": "#!/osrf/sdformat/pull-requests/492"}, "activity": {"href": "data/repositories/osrf/sdformat/pullrequests/492/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/sdformat/diff/osrf/sdformat:075d85ff6c88%0Dd2436327aef2?from_pullrequest_id=492"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/sdformat/pullrequests/492/approve"}, "statuses": {"href": "data/repositories/osrf/sdformat/pullrequests/492/statuses_page=1.json"}}, "title": "Fix locale problems of std::stringstream and of Param::ValueFromString", "close_source_branch": false, "reviewers": [], "id": 492, "destination": {"commit": {"hash": "d2436327aef2", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/sdformat/commit/d2436327aef2.json"}, "html": {"href": "#!/osrf/sdformat/commits/d2436327aef2"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/sdformat.json"}, "html": {"href": "#!/osrf/sdformat"}, "avatar": {"href": "data/bytebucket.org/ravatar/{b6d52f9f-b070-41c0-807c-94af07ea375b}ts=1606789"}}, "type": "repository", "name": "sdformat", "full_name": "osrf/sdformat", "uuid": "{b6d52f9f-b070-41c0-807c-94af07ea375b}"}, "branch": {"name": "gz11"}}, "created_on": "2018-12-29T23:53:41.950701+00:00", "summary": {"raw": "Fix for the issue described in [#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if](#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if) and other potential errors due to the use of `std::stringstream`.\r\n\r\n~~For uniforming the code, handling of double and float parameters have been switched to use~~ `std::stringstream` ~~as well.~~\r\n\r\nThere are two separated fixes:\r\n\r\n* Introduce a private helper `StringStreamClassicLocale` that is just `std::stringstream` with `imbue(std::locale::classic()` called in the constructor. Use of this helper ensures that the parsing is independent from the C\\+\\+ global locale set via `std::locale::global()`.\r\n* Move the `setlocale(LC_NUMERIC, \"C\");` from `Param::SetFromString` to `Param::ValueFromString`, so the case in which the `Param::ValueFromString` method was first called by the Param constructor is covered as well.\r\n\r\nIf necessary, it is possible to split this two fixes in two PRs.\r\n\r\nI would have preferred to switch all conversions to C\\+\\+ facilities, removing the existing modifications of the global C locale, that are error-prone as any thread in the process could call `std::locale(\"\")` between sdformat's `std::locale` call and the calls to `stod` and `stof`.\r\n\r\nUnfortunately it turns out that removing `std::stod` is not trivial, as `stod` supports reading hexadecimal floating point numbers \\([https://en.cppreference.com/w/cpp/string/basic\\_string/stof](https://en.cppreference.com/w/cpp/string/basic_string/stof)\\), that are not supported instead by `stringstream& operator>>(double& value);` . The situation on this is a bit confusing from a user point of view, because as far as I could find, sdformat specification does not specify which representations it supports for double and float numbers. XML-based formats typically stick to support only `xsd::double` \\(see [https://www.w3.org/TR/xmlschema-2/#double](https://www.w3.org/TR/xmlschema-2/#double) and [https://github.com/ros/urdfdom\\_headers/issues/41#issuecomment-345737929](https://github.com/ros/urdfdom_headers/issues/41#issuecomment-345737929)\\) that **does not** support hexadecimal doubles, and indeed this is what is documented in the XML Schema generated by sdformat. Furthermore, hexadecimal double are only supported in scalar values, while when reading vectors the only representations supported are the one supported by `stringstream& operator>>(double& value);` . It probably make sense to discuss this in a separate issue.", "markup": "markdown", "html": "<p>Fix for the issue described in <a data-is-external-link=\"true\" href=\"#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if\" rel=\"nofollow\">#!/osrf/sdformat/issues/207/error-when-starting-ign-gazebo-if</a> and other potential errors due to the use of <code>std::stringstream</code>.</p>\n<p><del>For uniforming the code, handling of double and float parameters have been switched to use</del> <code>std::stringstream</code> <del>as well.</del></p>\n<p>There are two separated fixes:</p>\n<ul>\n<li>Introduce a private helper <code>StringStreamClassicLocale</code> that is just <code>std::stringstream</code> with <code>imbue(std::locale::classic()</code> called in the constructor. Use of this helper ensures that the parsing is independent from the C++ global locale set via <code>std::locale::global()</code>.</li>\n<li>Move the <code>setlocale(LC_NUMERIC, \"C\");</code> from <code>Param::SetFromString</code> to <code>Param::ValueFromString</code>, so the case in which the <code>Param::ValueFromString</code> method was first called by the Param constructor is covered as well.</li>\n</ul>\n<p>If necessary, it is possible to split this two fixes in two PRs.</p>\n<p>I would have preferred to switch all conversions to C++ facilities, removing the existing modifications of the global C locale, that are error-prone as any thread in the process could call <code>std::locale(\"\")</code> between sdformat's <code>std::locale</code> call and the calls to <code>stod</code> and <code>stof</code>.</p>\n<p>Unfortunately it turns out that removing <code>std::stod</code> is not trivial, as <code>stod</code> supports reading hexadecimal floating point numbers (<a data-is-external-link=\"true\" href=\"https://en.cppreference.com/w/cpp/string/basic_string/stof\" rel=\"nofollow\">https://en.cppreference.com/w/cpp/string/basic_string/stof</a>), that are not supported instead by <code>stringstream&amp; operator&gt;&gt;(double&amp; value);</code> . The situation on this is a bit confusing from a user point of view, because as far as I could find, sdformat specification does not specify which representations it supports for double and float numbers. XML-based formats typically stick to support only <code>xsd::double</code> (see <a data-is-external-link=\"true\" href=\"https://www.w3.org/TR/xmlschema-2/#double\" rel=\"nofollow\">https://www.w3.org/TR/xmlschema-2/#double</a> and <a data-is-external-link=\"true\" href=\"https://github.com/ros/urdfdom_headers/issues/41#issuecomment-345737929\" rel=\"nofollow\">https://github.com/ros/urdfdom_headers/issues/41#issuecomment-345737929</a>) that <strong>does not</strong> support hexadecimal doubles, and indeed this is what is documented in the XML Schema generated by sdformat. Furthermore, hexadecimal double are only supported in scalar values, while when reading vectors the only representations supported are the one supported by <code>stringstream&amp; operator&gt;&gt;(double&amp; value);</code> . It probably make sense to discuss this in a separate issue.</p>", "type": "rendered"}, "source": {"commit": {"hash": "f9ad0a233794", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/traversaro/sdformat/commit/f9ad0a233794"}, "html": {"href": "https://bitbucket.org/traversaro/sdformat/commits/f9ad0a233794"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/traversaro/sdformat"}, "html": {"href": "https://bitbucket.org/traversaro/sdformat"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e8677ce0-8f62-4623-a535-f4140583deb5}ts=c_plus_plus"}}, "type": "repository", "name": "sdformat", "full_name": "traversaro/sdformat", "uuid": "{e8677ce0-8f62-4623-a535-f4140583deb5}"}, "branch": {"name": "fix_locale"}}, "comment_count": 9, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2019-01-04T22:57:50.578001+00:00", "type": "participant", "approved": false, "user": {"display_name": "Silvio Traversaro", "uuid": "{34f404cb-5642-4f27-a032-e04c7143d776}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B34f404cb-5642-4f27-a032-e04c7143d776%7D"}, "html": {"href": "https://bitbucket.org/%7B34f404cb-5642-4f27-a032-e04c7143d776%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e1c3e6a0-9a64-4e5f-a668-feebc191c5b6/578caaa1-056c-45a2-8bf9-bee94c3bebef/128"}}, "nickname": "traversaro", "type": "user", "account_id": "557058:e1c3e6a0-9a64-4e5f-a668-feebc191c5b6"}}, {"role": "PARTICIPANT", "participated_on": "2019-01-04T17:28:27.734527+00:00", "type": "participant", "approved": true, "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}}, {"role": "PARTICIPANT", "participated_on": "2019-01-04T17:15:06.030181+00:00", "type": "participant", "approved": true, "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}], "reason": "", "updated_on": "2019-01-04T22:57:50.584872+00:00", "author": {"display_name": "Silvio Traversaro", "uuid": "{34f404cb-5642-4f27-a032-e04c7143d776}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B34f404cb-5642-4f27-a032-e04c7143d776%7D"}, "html": {"href": "https://bitbucket.org/%7B34f404cb-5642-4f27-a032-e04c7143d776%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e1c3e6a0-9a64-4e5f-a668-feebc191c5b6/578caaa1-056c-45a2-8bf9-bee94c3bebef/128"}}, "nickname": "traversaro", "type": "user", "account_id": "557058:e1c3e6a0-9a64-4e5f-a668-feebc191c5b6"}, "merge_commit": {"hash": "075d85ff6c88", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/sdformat/commit/075d85ff6c88.json"}, "html": {"href": "#!/osrf/sdformat/commits/075d85ff6c88"}}}, "closed_by": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}}